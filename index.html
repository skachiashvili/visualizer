<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microstructure Thermal Simulation</title>
    
    <!-- Update to specific Plotly version instead of latest -->
    <script src="https://cdn.plot.ly/plotly-2.29.0.min.js"></script>
    
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --background-color: #f5f7fa;
            --card-color: #ffffff;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --tab-active-color: #3498db;
            --tab-inactive-color: #e0e0e0;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: var(--card-color);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h2 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .controls-panel {
            background-color: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            border-bottom: 3px solid var(--tab-active-color);
            color: var(--tab-active-color);
        }
        
        .tab-content {
            display: none;
            padding: 10px 0;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .control-group {
            flex: 1;
            min-width: 200px;
            display: flex;
            flex-direction: column;
        }
        
        label {
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }
        
        input[type="number"] {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 16px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 4px;
            outline: none;
            margin-top: 5px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .value-display {
            font-size: 14px;
            color: #666;
            margin-top: 8px;
            text-align: center;
        }
        
        button {
            padding: 12px 24px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #27ae60;
        }
        
        .button-container {
            display: flex;
            justify-content: center;
            margin-top: 15px;
        }
        
        .info-panel {
            background-color: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 15px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .info-item {
            padding: 5px;
        }
        
        .plot-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .plot-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .plot-button:hover {
            background-color: #2980b9;
            transform: translateY(-1px);
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
        }
        
        .plot-button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        /* Style for plotly to fill the container properly */
        .plot > div {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .upload-container {
            margin-top: 15px;
            padding: 15px;
            background-color: #f0f7ff;
            border-radius: 8px;
            border: 1px dashed #3498db;
        }
        
        .upload-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #555;
        }
        
        .upload-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .upload-info {
            color: #666;
            font-size: 0.85em;
        }
        
        #process-upload-btn, #process-drawing-btn {
            background-color: var(--primary-color);
            padding: 8px 16px;
        }
        
        #process-upload-btn:disabled, #process-drawing-btn:disabled {
            background-color: #a0cfee;
            cursor: not-allowed;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
        
        /* Drawing canvas styles */
        .drawing-container {
            margin-top: 15px;
            padding: 15px;
            background-color: #f0f7ff;
            border-radius: 8px;
            border: 1px dashed #3498db;
        }
        
        #drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .drawing-tools {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .drawing-tool {
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .drawing-tool:hover {
            background-color: #2980b9;
        }
        
        .drawing-tool.active {
            background-color: #e74c3c;
        }
        
        .brush-size {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .shape-tools {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .shape-tool {
            padding: 6px 12px;
            background-color: #7f8c8d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .shape-tool:hover {
            background-color: #6c7a7a;
        }
        
        .drawing-hints {
            text-align: center;
            margin-top: 10px;
            color: #555;
            font-size: 14px;
        }
        
        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            font-weight: normal;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Tutorial panel */
        .tutorial-panel {
            background-color: #fee;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #e74c3c;
        }
        
        .tutorial-panel h3 {
            color: #c0392b;
            margin-bottom: 10px;
        }
        
        .tutorial-panel ul {
            padding-left: 20px;
        }
        
        .tutorial-panel li {
            margin-bottom: 5px;
        }
        
        /* IMPROVED UI STYLES */
        /* Update plot container layout for 2x2 grid */
        .plot-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .plot-wrapper {
            margin-bottom: 0;
        }

        /* Fix the plot size issues when toggling modes */
        .plot {
            width: 100%;
            padding-bottom: 85%; /* Fixed aspect ratio for plots */
            min-height: 300px;
            position: relative;
        }

        /* Make drawing toolbar more compact and organized */
        .drawing-toolbar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
            background: #f0f7ff;
            padding: 12px;
            border-radius: 8px;
        }

        /* Enhance drawing actions layout */
        .drawing-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        #drawing-canvas-container {
            margin: 0;
            border: 2px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            background-color: black;
            position: relative;
            width: 400px;
            height: 400px;
            cursor: crosshair;
            overflow: hidden;
        }

        /* Add tab transition effects */
        .tab {
            transition: all 0.3s ease;
        }

        .tab:hover {
            background-color: #f0f7ff;
        }
        
        /* Drawing help */
        .drawing-help {
            margin-top: 5px;
            color: #666;
            font-size: 0.85em;
        }
        
        .drawing-help kbd {
            background-color: #f7f7f7;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-shadow: 0 1px 0 rgba(0,0,0,0.2);
            color: #333;
            display: inline-block;
            font-size: 11px;
            line-height: 1;
            padding: 2px 4px;
            white-space: nowrap;
        }
        
        .drawing-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        /* BUTTON SPACING FIX */
        /* Improve toolbar buttons layout and spacing */
        .toolbar-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
        }

        /* Fix button spacing and text alignment */
        .drawing-tool, .shape-tool {
            padding: 8px 12px;
            margin: 0;
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-height: 36px;
            min-width: 80px;
        }

        /* Fix keyboard shortcut spacing */
        .keyboard-shortcut {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            margin-left: 4px;
            font-weight: normal;
            display: inline-block;
            padding: 1px 3px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        /* Improve brush size control spacing */
        .brush-size {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
            padding: 4px 8px;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            width: 100%;
        }

        .brush-size label {
            margin: 0;
            font-size: 12px;
            white-space: nowrap;
            min-width: 32px;
        }

        .brush-size input[type="range"] {
            flex: 1;
            margin: 0;
        }

        #brush-size-value {
            min-width: 40px;
            text-align: right;
            font-size: 12px;
        }

        /* Improve toolbar section spacing */
        .toolbar-section {
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            margin-bottom: 0;
        }

        /* Fix dropdown header spacing */
        .toolbar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 4px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }

        /* Fix spacing of toolbar content */
        .toolbar-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding-top: 2px;
        }

        /* Adjust dropdown toggle icon */
        .toggle-icon {
            font-size: 14px;
            transition: transform 0.3s ease;
            margin-left: 8px;
            width: 20px;
            height: 20px;
            text-align: center;
            line-height: 20px;
            background: rgba(0,0,0,0.05);
            border-radius: 50%;
        }

        /* Fix select dropdown spacing */
        #load-drawing-select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            flex: 1;
            min-width: 120px;
            font-size: 14px;
        }
        
        /* Layout improvements for mobile */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
            
            .plot-container {
                grid-template-columns: 1fr;
            }
            
            .plot {
                height: 300px;
            }
            
            .upload-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            #drawing-canvas-container {
                width: 100%;
                height: auto;
                aspect-ratio: 1/1;
            }
            
            .drawing-toolbar {
                flex-direction: column;
            }
            
            .drawing-actions {
                flex-direction: column;
                gap: 10px;
                grid-template-columns: 1fr;
            }
            
            .toolbar-section {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Microstructure Thermal Simulation</h1>
        
        <div class="tutorial-panel" id="tutorial-panel">
            <h3>How to Use This Tool</h3>
            <ul>
                <li><strong>Choose Method:</strong> Select from preset microstructures, upload your own image, or draw a custom design.</li>
                <li><strong>Set Parameters:</strong> Adjust the thermal conductivity ratio (κ₁) and direction angle (α) to see how they affect heat transfer.</li>
                <li><strong>Analyze Results:</strong> View heat flux and temperature distribution across your microstructure.</li>
                <li><strong>Interact:</strong> Zoom, pan, and download any visualization for further analysis.</li>
            </ul>
            <div class="button-container">
                <button id="hide-tutorial" style="background-color: #e74c3c; padding: 8px 16px; margin-top: 10px;">Hide Tutorial</button>
            </div>
        </div>
        
        <div class="controls-panel">
            <div class="tabs">
                <div class="tab active" data-tab="preset">Preset Microstructures</div>
                <div class="tab" data-tab="upload">Upload Image</div>
                <div class="tab" data-tab="draw">Draw Custom</div>
            </div>
            
            <!-- Common controls for all modes -->
            <div class="controls">
                <div class="control-group">
                    <label for="kappa1" class="tooltip">
                        κ₁ [W/m²]:
                        <span class="tooltiptext">Thermal conductivity ratio between phases. Higher values = greater conductivity difference.</span>
                    </label>
                    <input type="range" id="kappa1" min="0.1" max="10" step="0.1" value="0.2">
                    <div class="value-display" id="kappa1-value">0.2</div>
                </div>
                
                <div class="control-group">
                    <label for="alpha" class="tooltip">
                        α [°]:
                        <span class="tooltiptext">Direction of thermal gradient. Changes the direction of heat flow.</span>
                    </label>
                    <input type="range" id="alpha" min="0" max="90" step="1" value="0">
                    <div class="value-display" id="alpha-value">0°</div>
                </div>
            </div>
            
            <!-- Preset Microstructures Tab -->
            <div id="preset-tab" class="tab-content active">
                <div class="control-group">
                    <label for="ms-id" class="tooltip">
                        Microstructure ID:
                        <span class="tooltiptext">Select from available preset microstructures in the database.</span>
                    </label>
                    <input type="number" id="ms-id" min="0" value="37">
                </div>
                
                <div class="button-container">
                    <button id="update-btn">Load Microstructure</button>
                </div>
            </div>
            
            <!-- Upload Image Tab -->
            <div id="upload-tab" class="tab-content">
                <div class="upload-container">
                    <label for="image-upload" class="upload-label">Upload Custom Microstructure Image:</label>
                    <div class="upload-controls">
                        <input type="file" id="image-upload" accept="image/*">
                        <button id="process-upload-btn" disabled>Process Uploaded Image</button>
                    </div>
                    <div class="upload-info">
                        <small>Supported formats: PNG, JPEG, GIF. Images will be processed as binary (black/white) microstructures, where white represents the conductive phase.</small>
                    </div>
                </div>
            </div>
            
            <!-- Draw Custom Tab - IMPROVED VERSION -->
            <div id="draw-tab" class="tab-content">
                <div class="drawing-container">
                    <h2>Draw Custom Microstructure</h2>
                    
                    <div class="drawing-toolbar">
                        <div class="toolbar-section">
                            <div class="toolbar-header" onclick="toggleToolbarSection(this)">
                                <h4>Main Tools</h4>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="toolbar-content">
                                <div class="toolbar-buttons">
                                    <button class="drawing-tool active" id="draw-white" title="Draw with white (conductive phase)">White <span class="keyboard-shortcut">W</span></button>
                                    <button class="drawing-tool" id="draw-black" title="Draw with black (base phase)">Black <span class="keyboard-shortcut">B</span></button>
                                    <button class="drawing-tool" id="draw-eraser" title="Erase to black">Eraser <span class="keyboard-shortcut">E</span></button>
                                    <div class="brush-size">
                                        <label for="brush-size">Size:</label>
                                        <input type="range" id="brush-size" min="1" max="50" value="10" style="width: 100px">
                                        <span id="brush-size-value">10px</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="toolbar-section">
                            <div class="toolbar-header" onclick="toggleToolbarSection(this)">
                                <h4>Shapes & Patterns</h4>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="toolbar-content">
                                <div class="toolbar-buttons">
                                    <button class="shape-tool" id="draw-circle" title="Draw a white circle">Circle</button>
                                    <button class="shape-tool" id="draw-rectangle" title="Draw a white rectangle">Rectangle</button>
                                    <button class="shape-tool" id="draw-triangle" title="Draw a white triangle">Triangle</button>
                                    <button class="shape-tool" id="draw-line" title="Draw a straight line">Line</button>
                                    <button class="shape-tool" id="draw-grid" title="Generate a grid pattern">Grid</button>
                                    <button class="shape-tool" id="draw-checkerboard" title="Generate a checkerboard pattern">Checkerboard</button>
                                    <button class="shape-tool" id="draw-random" title="Generate random particles">Random</button>
                                    <button class="shape-tool" id="draw-voronoi" title="Generate a cellular pattern">Cellular</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="toolbar-section">
                            <div class="toolbar-header" onclick="toggleToolbarSection(this)">
                                <h4>Canvas Operations</h4>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="toolbar-content">
                                <div class="toolbar-buttons">
                                    <button class="drawing-tool" id="undo-btn" disabled title="Undo last action">Undo <span class="keyboard-shortcut">Ctrl+Z</span></button>
                                    <button class="drawing-tool" id="redo-btn" disabled title="Redo last undone action">Redo <span class="keyboard-shortcut">Ctrl+Y</span></button>
                                    <button class="drawing-tool tool-important" id="clear-canvas" title="Clear the entire canvas to black">Clear</button>
                                    <button class="drawing-tool" id="fill-white" title="Fill the entire canvas with white">Fill White</button>
                                    <button class="drawing-tool" id="fill-black" title="Fill the entire canvas with black">Fill Black</button>
                                    <button class="drawing-tool" id="invert-colors" title="Invert black and white">Invert</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="toolbar-section">
                            <div class="toolbar-header" onclick="toggleToolbarSection(this)">
                                <h4>Save & Load</h4>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="toolbar-content">
                                <div class="toolbar-buttons">
                                    <button class="drawing-tool tool-action" id="save-drawing-btn" title="Save this drawing locally">Save</button>
                                    <select id="load-drawing-select" title="Load a saved drawing">
                                        <option value="">-- Load Drawing --</option>
                                    </select>
                                    <button class="drawing-tool" id="delete-drawing-btn" title="Delete the selected saved drawing">Delete</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="drawing-actions">
                        <div id="drawing-canvas-container">
                            <canvas id="drawing-canvas" width="400" height="400"></canvas>
                        </div>
                        
                        <div class="drawing-info">
                            <div class="drawing-help">
                                <h4>Keyboard Shortcuts</h4>
                                <ul>
                                    <li><kbd>W</kbd> - White tool</li>
                                    <li><kbd>B</kbd> - Black tool</li>
                                    <li><kbd>E</kbd> - Eraser</li>
                                    <li><kbd>Ctrl+Z</kbd> - Undo</li>
                                    <li><kbd>Ctrl+Y</kbd> - Redo</li>
                                    <li><kbd>Esc</kbd> - Cancel current action</li>
                                </ul>
                            </div>
                            
                            <div class="drawing-hints">
                                <p><strong>White</strong> = conductive phase (κ₁)</p>
                                <p><strong>Black</strong> = base phase (κ₀)</p>
                                <p>Draw a two-phase structure for best results.</p>
                            </div>
                            
                            <div class="button-container" style="margin-top: 20px;">
                                <button id="process-drawing-btn" class="tool-important">Process Drawing</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="info-panel" id="info-panel">
            <p>Welcome to the Microstructure Thermal Simulation tool. Select a microstructure source (preset, upload, or draw) and adjust parameters to see results.</p>
        </div>
        
        <!-- IMPROVED PLOT GRID LAYOUT -->
        <div class="plot-container">
            <div class="plot-wrapper">
                <div class="plot-controls">
                    <button class="plot-button" data-plot-id="microstructure-plot" data-action="reset">Reset</button>
                    <button class="plot-button" data-plot-id="microstructure-plot" data-action="download">Download</button>
                    <button class="plot-button" data-plot-id="microstructure-plot" data-action="toggle">Toggle Mode</button>
                </div>
                <div class="plot" id="microstructure-plot"></div>
            </div>
            
            <div class="plot-wrapper">
                <div class="plot-controls">
                    <button class="plot-button" data-plot-id="param-field-plot" data-action="reset">Reset</button>
                    <button class="plot-button" data-plot-id="param-field-plot" data-action="download">Download</button>
                    <button class="plot-button" data-plot-id="param-field-plot" data-action="toggle">Toggle Mode</button>
                </div>
                <div class="plot" id="param-field-plot"></div>
            </div>
            
            <div class="plot-wrapper">
                <div class="plot-controls">
                    <button class="plot-button" data-plot-id="temp0-plot" data-action="reset">Reset</button>
                    <button class="plot-button" data-plot-id="temp0-plot" data-action="download">Download</button>
                    <button class="plot-button" data-plot-id="temp0-plot" data-action="toggle">Toggle Mode</button>
                </div>
                <div class="plot" id="temp0-plot"></div>
            </div>
            
            <div class="plot-wrapper">
                <div class="plot-controls">
                    <button class="plot-button" data-plot-id="temp1-plot" data-action="reset">Reset</button>
                    <button class="plot-button" data-plot-id="temp1-plot" data-action="download">Download</button>
                    <button class="plot-button" data-plot-id="temp1-plot" data-action="toggle">Toggle Mode</button>
                </div>
                <div class="plot" id="temp1-plot"></div>
            </div>
            
            <div class="plot-wrapper">
                <div class="plot-controls">
                    <button class="plot-button" data-plot-id="flux0-plot" data-action="reset">Reset</button>
                    <button class="plot-button" data-plot-id="flux0-plot" data-action="download">Download</button>
                    <button class="plot-button" data-plot-id="flux0-plot" data-action="toggle">Toggle Mode</button>
                </div>
                <div class="plot" id="flux0-plot"></div>
            </div>
            
            <div class="plot-wrapper">
                <div class="plot-controls">
                    <button class="plot-button" data-plot-id="flux1-plot" data-action="reset">Reset</button>
                    <button class="plot-button" data-plot-id="flux1-plot" data-action="download">Download</button>
                    <button class="plot-button" data-plot-id="flux1-plot" data-action="toggle">Toggle Mode</button>
                </div>
                <div class="plot" id="flux1-plot"></div>
            </div>
        </div>
        
        <div id="loading" class="loading-overlay hidden">
            <div class="spinner"></div>
        </div>
    </div>
    
    <script>
        // DOM Elements
        const msIdInput = document.getElementById('ms-id');
        const kappa1Input = document.getElementById('kappa1');
        const kappa1Value = document.getElementById('kappa1-value');
        const alphaInput = document.getElementById('alpha');
        const alphaValue = document.getElementById('alpha-value');
        const updateBtn = document.getElementById('update-btn');
        const infoPanel = document.getElementById('info-panel');
        const loadingOverlay = document.getElementById('loading');
        const imageUpload = document.getElementById('image-upload');
        const processUploadBtn = document.getElementById('process-upload-btn');
        const processDrawingBtn = document.getElementById('process-drawing-btn');
        const tabButtons = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const hideTutorialBtn = document.getElementById('hide-tutorial');
        const tutorialPanel = document.getElementById('tutorial-panel');
        
        // Canvas-related elements
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const drawWhiteBtn = document.getElementById('draw-white');
        const drawBlackBtn = document.getElementById('draw-black');
        const eraserBtn = document.getElementById('draw-eraser');
        const clearCanvasBtn = document.getElementById('clear-canvas');
        const fillWhiteBtn = document.getElementById('fill-white');
        const fillBlackBtn = document.getElementById('fill-black');
        const invertColorsBtn = document.getElementById('invert-colors');
        const brushSizeInput = document.getElementById('brush-size');
        const brushSizeValue = document.getElementById('brush-size-value');
        
        // Shape tools
        const circleBtn = document.getElementById('draw-circle');
        const rectangleBtn = document.getElementById('draw-rectangle');
        const gridBtn = document.getElementById('draw-grid');
        const randomBtn = document.getElementById('draw-random');
        
        // Plot containers
        const microPlot = document.getElementById('microstructure-plot');
        const paramFieldPlot = document.getElementById('param-field-plot');
        const temp0Plot = document.getElementById('temp0-plot');
        const temp1Plot = document.getElementById('temp1-plot');
        const flux0Plot = document.getElementById('flux0-plot');
        const flux1Plot = document.getElementById('flux1-plot');
        
        // API endpoints
        const API_INFO = '/api/info';
        const API_SIMULATE = '/api/simulate';
        const API_UPLOAD = '/api/upload-microstructure';
        const API_DRAWING = '/api/process-drawing';
        
        // App state
        let maxSampleId = 100; // Default, will be updated from API
        let hasSurrogate = false;
        let currentTab = 'preset';
        let isDrawing = false;
        let currentResults = null;
        
        // Drawing state
        let drawColor = '#FFFFFF'; // Default to white
        let brushSize = 10;
        let lastX = 0;
        let lastY = 0;
        
        // Canvas state history for undo/redo
        let canvasHistory = [];
        let currentHistoryIndex = -1;
        const maxHistoryStates = 20; // Limit to prevent memory issues
        
        // FIXED toggleToolbarSection function
        function toggleToolbarSection(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.toggle-icon');
            
            if (content.classList.contains('collapsed')) {
                // Expand section
                content.classList.remove('collapsed');
                content.style.maxHeight = content.scrollHeight + "px";
                icon.classList.remove('collapsed');
            } else {
                // Collapse section
                content.classList.add('collapsed');
                content.style.maxHeight = "0px";
                icon.classList.add('collapsed');
            }
        }

        // Save current canvas state to history
        function saveCanvasState() {
            // If we're not at the end of the history, truncate it
            if (currentHistoryIndex < canvasHistory.length - 1) {
                canvasHistory = canvasHistory.slice(0, currentHistoryIndex + 1);
            }
            
            // Save current state
            const state = canvas.toDataURL();
            canvasHistory.push(state);
            
            // Keep history within size limit
            if (canvasHistory.length > maxHistoryStates) {
                canvasHistory.shift();
                currentHistoryIndex = Math.max(0, currentHistoryIndex - 1);
            } else {
                currentHistoryIndex = canvasHistory.length - 1;
            }
            
            // Update undo/redo button states
            document.getElementById('undo-btn').disabled = currentHistoryIndex <= 0;
            document.getElementById('redo-btn').disabled = currentHistoryIndex >= canvasHistory.length - 1;
        }

        // Restore canvas from history
        function restoreCanvasState(index) {
            if (index < 0 || index >= canvasHistory.length) return;
            
            currentHistoryIndex = index;
            
            const img = new Image();
            img.onload = function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            };
            img.src = canvasHistory[index];
            
            // Update undo/redo button states
            document.getElementById('undo-btn').disabled = currentHistoryIndex <= 0;
            document.getElementById('redo-btn').disabled = currentHistoryIndex >= canvasHistory.length - 1;
        }

        // Undo function
        function undoCanvas() {
            if (currentHistoryIndex > 0) {
                restoreCanvasState(currentHistoryIndex - 1);
            }
        }

        // Redo function
        function redoCanvas() {
            if (currentHistoryIndex < canvasHistory.length - 1) {
                restoreCanvasState(currentHistoryIndex + 1);
            }
        }

        // Save/load functionality
        function saveDrawing() {
            const name = prompt('Enter a name for this drawing:');
            if (!name) return;
            
            const drawings = JSON.parse(localStorage.getItem('microstructureDrawings') || '{}');
            drawings[name] = canvas.toDataURL();
            localStorage.setItem('microstructureDrawings', JSON.stringify(drawings));
            
            updateDrawingsList();
        }

        function loadDrawing(name) {
            const drawings = JSON.parse(localStorage.getItem('microstructureDrawings') || '{}');
            if (!drawings[name]) return;
            
            const img = new Image();
            img.onload = function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                saveCanvasState();
            };
            img.src = drawings[name];
        }

        function deleteDrawing() {
            const select = document.getElementById('load-drawing-select');
            const name = select.value;
            if (!name) return;
            
            if (confirm(`Are you sure you want to delete "${name}"?`)) {
                const drawings = JSON.parse(localStorage.getItem('microstructureDrawings') || '{}');
                delete drawings[name];
                localStorage.setItem('microstructureDrawings', JSON.stringify(drawings));
                
                updateDrawingsList();
            }
        }

        function updateDrawingsList() {
            const select = document.getElementById('load-drawing-select');
            const drawings = JSON.parse(localStorage.getItem('microstructureDrawings') || '{}');
            
            // Clear all options except the first one
            while (select.options.length > 1) {
                select.remove(1);
            }
            
            // Add options for each saved drawing
            for (const name in drawings) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            }
        }

        // Additional shape tools
        function drawLine() {
    let startX, startY;
    let isDrawingLine = false;
    let tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    let tempCtx = tempCanvas.getContext('2d');
    
    // Copy current canvas to temp
    tempCtx.drawImage(canvas, 0, 0);
    
    function startLine(e) {
        isDrawingLine = true;
        const rect = canvas.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        
        // Add event listeners for drawing line
        canvas.addEventListener('mousemove', drawingLine);
        canvas.addEventListener('mouseup', endLine);
        canvas.addEventListener('mouseout', endLine); // Also end line when mouse leaves canvas
    }
    
    function drawingLine(e) {
        if (!isDrawingLine) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Clear canvas and redraw temp canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(tempCanvas, 0, 0);
        
        // Draw line
        ctx.beginPath();
        ctx.strokeStyle = drawColor;
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.stroke();
    }
    
    function endLine(e) {
        if (!isDrawingLine) return;
        
        isDrawingLine = false;
        canvas.removeEventListener('mousemove', drawingLine);
        canvas.removeEventListener('mouseup', endLine);
        canvas.removeEventListener('mouseout', endLine);
        
        // Save the state after drawing the line
        saveCanvasState();
        
        // Auto-restore normal drawing mode when line is complete
        restoreNormalDrawing();
        
        // Reset active tool to previous drawing tool
        if (drawColor === '#FFFFFF') {
            setActiveDrawingTool(drawWhiteBtn);
        } else {
            setActiveDrawingTool(drawBlackBtn);
        }
    }
    
    // Override normal drawing behavior temporarily
    canvas.removeEventListener('mousedown', startDrawing);
    canvas.removeEventListener('mousemove', draw);
    canvas.removeEventListener('mouseup', stopDrawing);
    canvas.removeEventListener('mouseout', stopDrawing);
    
    // Add line drawing behavior
    canvas.addEventListener('mousedown', startLine);
    
    // Function to restore normal drawing behavior
    function restoreNormalDrawing() {
        canvas.removeEventListener('mousedown', startLine);
        canvas.removeEventListener('mousemove', drawingLine);
        canvas.removeEventListener('mouseup', endLine);
        canvas.removeEventListener('mouseout', endLine);
        
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        // Clear the current drawing mode reference
        currentDrawingMode = null;
    }
    
    // Return the cleanup function to be called when another tool is selected
    return restoreNormalDrawing;
}

        // Draw a triangle shape
        function drawTriangle() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const size = Math.min(canvas.width, canvas.height) / 3;
            
            ctx.beginPath();
            ctx.fillStyle = '#FFFFFF';
            ctx.moveTo(centerX, centerY - size);
            ctx.lineTo(centerX - size, centerY + size);
            ctx.lineTo(centerX + size, centerY + size);
            ctx.closePath();
            ctx.fill();
            
            saveCanvasState();
        }

        // Generate checkerboard pattern
        function drawCheckerboard() {
            const gridSize = 16; // Number of cells in each direction
            const cellWidth = canvas.width / gridSize;
            const cellHeight = canvas.height / gridSize;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFFFFF';
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if ((i + j) % 2 === 0) {
                        ctx.fillRect(i * cellWidth, j * cellHeight, cellWidth, cellHeight);
                    }
                }
            }
            
            saveCanvasState();
        }

        // Generate a voronoi-like cellular pattern
        function drawVoronoi() {
            const numPoints = 30;
            const points = [];
            
            // Generate random points
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                });
            }
            
            // Fill canvas with black
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // For each pixel, find closest point and color accordingly
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let x = 0; x < canvas.width; x++) {
                for (let y = 0; y < canvas.height; y++) {
                    let closestDistance = Infinity;
                    let closestIndex = 0;
                    
                    // Find closest point
                    for (let i = 0; i < numPoints; i++) {
                        const dx = points[i].x - x;
                        const dy = points[i].y - y;
                        const distance = dx * dx + dy * dy;
                        
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestIndex = i;
                        }
                    }
                    
                    // Color based on closest point (even index = white, odd = black)
                    const pixelIndex = (y * canvas.width + x) * 4;
                    const color = closestIndex % 2 === 0 ? 255 : 0;
                    data[pixelIndex] = color;     // R
                    data[pixelIndex + 1] = color; // G
                    data[pixelIndex + 2] = color; // B
                    data[pixelIndex + 3] = 255;   // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveCanvasState();
        }

        // Keyboard shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Only apply shortcuts when draw tab is active
                if (currentTab !== 'draw') return;
                
                // Ctrl+Z for undo
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    undoCanvas();
                }
                
                // Ctrl+Y for redo
                if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    redoCanvas();
                }
                
                // 'B' for black drawing tool
                if (e.key === 'b' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    setActiveDrawingTool(drawBlackBtn);
                    drawColor = '#000000';
                }
                
                // 'W' for white drawing tool
                if (e.key === 'w' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    setActiveDrawingTool(drawWhiteBtn);
                    drawColor = '#FFFFFF';
                }
                
                // 'E' for eraser
                if (e.key === 'e' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    setActiveDrawingTool(eraserBtn);
                }
                
                // Escape to cancel current action
                if (e.key === 'Escape') {
                    // If we're in a special drawing mode, revert to normal
                    if (currentDrawingMode) {
                        currentDrawingMode();
                        currentDrawingMode = null;
                    }
                }
            });
        }

        // Variable to track special drawing modes
        let currentDrawingMode = null;

        // Modified function to initialize drawing tools
        function initializeDrawingTools() {
            // Initialize undo/redo buttons
            document.getElementById('undo-btn').addEventListener('click', undoCanvas);
            document.getElementById('redo-btn').addEventListener('click', redoCanvas);
            document.getElementById('undo-btn').disabled = true;
            
            // Initialize save/load
            document.getElementById('save-drawing-btn').addEventListener('click', saveDrawing);
            document.getElementById('load-drawing-select').addEventListener('change', function() {
                if (this.value) {
                    loadDrawing(this.value);
                    this.selectedIndex = 0; // Reset dropdown
                }
            });
            document.getElementById('delete-drawing-btn').addEventListener('click', deleteDrawing);
            updateDrawingsList();
            
            // Initialize special drawing modes
            document.getElementById('draw-line').addEventListener('click', function() {
                if (currentDrawingMode) {
                    currentDrawingMode();
                }
                currentDrawingMode = drawLine();
            });
            
            document.getElementById('draw-triangle').addEventListener('click', function() {
                drawTriangle();
            });
            
            document.getElementById('draw-checkerboard').addEventListener('click', function() {
                drawCheckerboard();
            });
            
            document.getElementById('draw-voronoi').addEventListener('click', function() {
                drawVoronoi();
            });
            
            // Set up keyboard shortcuts
            setupKeyboardShortcuts();
            
            // Save initial canvas state
            saveCanvasState();
        }

        // Modified stopDrawing function to save state history
        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveCanvasState(); // Save state after drawing ends
            }
        }
        
        // Initialize canvas with black background
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Tab switching
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                
                // Update active tab button
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Update active tab content
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabId}-tab`).classList.add('active');
                
                // Set current tab
                currentTab = tabId;
            });
        });
        
        // Drawing tools setup
        drawWhiteBtn.addEventListener('click', () => {
            setActiveDrawingTool(drawWhiteBtn);
            drawColor = '#FFFFFF';
        });
        
        drawBlackBtn.addEventListener('click', () => {
            setActiveDrawingTool(drawBlackBtn);
            drawColor = '#000000';
        });
        
        eraserBtn.addEventListener('click', () => {
            setActiveDrawingTool(eraserBtn);
            drawColor = '#000000';
        });
        
        // Update brush size
        brushSizeInput.addEventListener('input', () => {
            brushSize = parseInt(brushSizeInput.value);
            brushSizeValue.textContent = `${brushSize}px`;
        });
        
        // Canvas drawing functions
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('mousemove', draw);
        
        // Touch support for mobile devices
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchmove', handleTouchMove);
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }
        
        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            ctx.beginPath();
            ctx.strokeStyle = drawColor;
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();
            
            lastX = x;
            lastY = y;
        }
        
        // Set active drawing tool
        function setActiveDrawingTool(activeButton) {
            // Remove active class from all drawing tools
            document.querySelectorAll('.drawing-tool').forEach(btn => {
                if (btn !== clearCanvasBtn && 
                    btn !== fillWhiteBtn && 
                    btn !== fillBlackBtn && 
                    btn !== invertColorsBtn && 
                    btn !== processDrawingBtn) {
                    btn.classList.remove('active');
                }
            });
            
            // Add active class to the selected button
            activeButton.classList.add('active');
        }
        
        // Clear the canvas
        clearCanvasBtn.addEventListener('click', () => {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveCanvasState();
        });
        
        // Fill the canvas with white
        fillWhiteBtn.addEventListener('click', () => {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveCanvasState();
        });
        
        // Fill the canvas with black
        fillBlackBtn.addEventListener('click', () => {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveCanvasState();
        });
        
        // Invert canvas colors
        invertColorsBtn.addEventListener('click', () => {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];       // Red
                data[i + 1] = 255 - data[i + 1]; // Green
                data[i + 2] = 255 - data[i + 2]; // Blue
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveCanvasState();
        });
        
        // Shape drawing tools
        circleBtn.addEventListener('click', () => {
            // Draw a white circle in the center
            const radius = Math.min(canvas.width, canvas.height) / 4;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#FFFFFF';
            ctx.fill();
            saveCanvasState();
        });
        
        rectangleBtn.addEventListener('click', () => {
            // Draw a white rectangle in the center
            const width = canvas.width / 2;
            const height = canvas.height / 2;
            const x = (canvas.width - width) / 2;
            const y = (canvas.height - height) / 2;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(x, y, width, height);
            saveCanvasState();
        });
        
        gridBtn.addEventListener('click', () => {
            // Draw a grid pattern
            const gridSize = 8; // Number of cells in each direction
            const cellWidth = canvas.width / gridSize;
            const cellHeight = canvas.height / gridSize;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFFFFF';
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    // Alternating pattern
                    if ((i + j) % 2 === 0) {
                        ctx.fillRect(i * cellWidth, j * cellHeight, cellWidth, cellHeight);
                    }
                }
            }
            saveCanvasState();
        });
        
        randomBtn.addEventListener('click', () => {
            // Draw random white particles
            const numParticles = 100;
            const maxRadius = 20;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFFFFF';
            for (let i = 0; i < numParticles; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 5 + Math.random() * maxRadius;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
            saveCanvasState();
        });
        
        // Hide tutorial
        hideTutorialBtn.addEventListener('click', () => {
            tutorialPanel.style.display = 'none';
        });
        
        // Debounce function to limit frequent updates
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }
        
        // Initialize the application
        async function initApp() {
            try {
                const response = await fetch(API_INFO);
                if (!response.ok) {
                    throw new Error('Failed to get API info');
                }
                
                const info = await response.json();
                maxSampleId = info.sample_count - 1;
                hasSurrogate = info.has_surrogate;
                
                // Update UI with limits
                msIdInput.max = maxSampleId;
                
                // Show info
                infoPanel.innerHTML = `
                    <p>
                        <strong>Dataset:</strong> ${info.sample_count} microstructures available (ID: 0-${maxSampleId})
                        <strong>Device:</strong> ${info.device}
                        <strong>Surrogate model:</strong> ${hasSurrogate ? 'Available' : 'Not available'}
                    </p>
                    <p>Select a microstructure source and adjust parameters to see thermal simulation results.</p>
                `;
                
                // Run initial simulation
                runSimulation();
                
            } catch (error) {
                console.error('Error initializing app:', error);
                infoPanel.innerHTML = `<p style="color: red;">Error initializing application: ${error.message}</p>`;
            }
        }
        
        // Helper function to transpose a matrix - using iterative approach to avoid stack overflow
        function transposeMatrix(matrix) {
            // Check if input is valid
            if (!Array.isArray(matrix) || matrix.length === 0) {
                console.error("Invalid matrix for transposition", matrix);
                return matrix; // Return original if invalid
            }
            
            // Handle non-matrix arrays by returning original
            if (!Array.isArray(matrix[0])) {
                return matrix;
            }
            
            const rows = matrix.length;
            const cols = matrix[0].length;
            const result = new Array(cols);
            
            // Iterative approach instead of using map (avoids call stack issues)
            for (let j = 0; j < cols; j++) {
                result[j] = new Array(rows);
                for (let i = 0; i < rows; i++) {
                    result[j][i] = matrix[i][j];
                }
            }
            
            return result;
        }
        
        // Update colorbar ticks based on visible data range - with better error handling
        function updateColorbarTicks(plotId) {
            try {
                const plotElement = document.getElementById(plotId);
                if (!plotElement || !plotElement.data || !plotElement.data[0] || !plotElement.layout) return;
                
                // Get current axis ranges
                const xRange = plotElement.layout.xaxis.range;
                const yRange = plotElement.layout.yaxis.range;
                
                if (!xRange || !yRange) return; // No zoom has occurred yet
                
                // Get data and dimensions
                const data = plotElement.data[0].z;
                if (!data || !data[0]) return;
                
                const rows = data.length;
                const cols = data[0].length;
                
                // Convert axis ranges to data indices, with careful bounds checking
                const xStart = Math.max(0, Math.floor(xRange[0]));
                const xEnd = Math.min(cols - 1, Math.ceil(xRange[1]));
                const yStart = Math.max(0, Math.floor(yRange[0]));
                const yEnd = Math.min(rows - 1, Math.ceil(yRange[1]));
                
                // Check for valid range
                if (xStart > xEnd || yStart > yEnd) return;
                
                // Find min/max in visible area
                let min = Infinity;
                let max = -Infinity;
                
                try {
                    // More careful iteration with bounds checking
                    for (let i = Math.max(0, yStart); i <= Math.min(rows - 1, yEnd); i++) {
                        if (!data[i]) continue;
                        for (let j = Math.max(0, xStart); j <= Math.min(cols - 1, xEnd); j++) {
                            if (data[i] && typeof data[i][j] === 'number' && !isNaN(data[i][j])) {
                                if (data[i][j] < min) min = data[i][j];
                                if (data[i][j] > max) max = data[i][j];
                            }
                        }
                    }
                } catch (e) {
                    console.error("Error finding min/max", e);
                    return; // Abort if we can't find min/max
                }
                
                // If we couldn't find valid min/max, don't update
                if (min === Infinity || max === -Infinity || isNaN(min) || isNaN(max)) return;
                
                // For temperature plots
                if (plotId.includes('temp')) {
                    // Generate more ticks between min and max (but keep within -0.08 to 0.08 range)
                    min = Math.max(-0.08, min);
                    max = Math.min(0.08, max);
                    
                    // Generate ticks at 0.01 intervals
                    const ticks = [];
                    const roundedMin = Math.floor(min * 100) / 100;
                    const roundedMax = Math.ceil(max * 100) / 100;
                    
                    for (let i = roundedMin; i <= roundedMax; i += 0.01) {
                        ticks.push(parseFloat(i.toFixed(2)));
                    }
                    
                    // Only attempt update if we have valid ticks
                    if (ticks.length > 0) {
                        try {
                            Plotly.relayout(plotElement, {
                                'coloraxis.colorbar.tickvals': ticks,
                                'coloraxis.colorbar.ticktext': ticks.map(val => val.toFixed(2))
                            });
                        } catch (e) {
                            console.error("Error updating colorbar", e);
                        }
                    }
                }
                
                // For flux plots
                else if (plotId.includes('flux')) {
                    // Generate more ticks between min and max (but keep within 0.4 to 1.4 range)
                    min = Math.max(0.4, min);
                    max = Math.min(1.4, max);
                    
                    // Generate ticks at 0.1 intervals
                    const ticks = [];
                    const roundedMin = Math.floor(min * 10) / 10;
                    const roundedMax = Math.ceil(max * 10) / 10;
                    
                    for (let i = roundedMin; i <= roundedMax; i += 0.1) {
                        ticks.push(parseFloat(i.toFixed(1)));
                    }
                    
                    // Only attempt update if we have valid ticks
                    if (ticks.length > 0) {
                        try {
                            Plotly.relayout(plotElement, {
                                'coloraxis.colorbar.tickvals': ticks,
                                'coloraxis.colorbar.ticktext': ticks.map(val => val.toFixed(1))
                            });
                        } catch (e) {
                            console.error("Error updating colorbar", e);
                        }
                    }
                }
            } catch (error) {
                console.error("Error updating colorbar ticks:", error);
            }
        }
        
        // Helper function to set up efficient zoom handlers (reused in createHeatmap and toggleDisplayMode)
        function setupEfficientZoomHandlers(container) {
            // Store last zoom state to avoid unnecessary updates
            if (!container._lastZoomState) {
                container._lastZoomState = null;
            }
            
            // Heavily debounced update function for better performance
            const efficientUpdateTicks = debounce(function() {
                try {
                    // Skip update if plot is being manipulated
                    if (container._isZooming) return;
                    
                    // Get current layout
                    if (!container.layout || !container.layout.xaxis || !container.layout.yaxis) return;
                    
                    // Get zoom state
                    const xRange = container.layout.xaxis.range;
                    const yRange = container.layout.yaxis.range;
                    if (!xRange || !yRange) return;
                    
                    // Create zoom state string for comparison
                    const zoomState = JSON.stringify({ xRange, yRange });
                    
                    // Skip if zoom hasn't changed significantly
                    if (container._lastZoomState === zoomState) return;
                    container._lastZoomState = zoomState;
                    
                    // Now it's safe to update ticks
                    updateColorbarTicks(container.id);
                } catch (err) {
                    console.error('Error in efficient update:', err);
                }
            }, 500); // Significant delay for better performance
            
            // Use separate handlers for different events
            container.on('plotly_relayout', function(eventData) {
                // Skip updates during active zooming (set by wheel events)
                if (container._isZooming) return;
                
                // Check if this is a zoom/pan event
                const isZoomEvent = eventData && (
                    eventData['xaxis.range[0]'] !== undefined ||
                    eventData['yaxis.range[0]'] !== undefined
                );
                
                if (isZoomEvent) {
                    efficientUpdateTicks();
                }
            });
            
            // Add wheel event listener to detect active zooming
            container.addEventListener('wheel', function() {
                // Mark as actively zooming
                container._isZooming = true;
                
                // Clear existing timeout if any
                if (container._zoomTimeout) {
                    clearTimeout(container._zoomTimeout);
                }
                
                // Set timeout to mark end of zooming and update ticks once
                container._zoomTimeout = setTimeout(function() {
                    container._isZooming = false;
                    efficientUpdateTicks();
                }, 500); // Wait for zooming to finish
            }, { passive: true }); // Use passive listener for better performance
        }
        
        // Create a heatmap visualization - IMPROVED VERSION
        function createHeatmap(container, data, title, colorscale = 'Jet', options = {}) {
    try {
        // Remove any existing plots to prevent memory leaks
        Plotly.purge(container);
        
        // Safely transpose the data - handle potential errors
        let transposedData;
        try {
            transposedData = transposeMatrix(data);
        } catch (error) {
            console.error("Error transposing data:", error);
            transposedData = data; // Fallback to original data
        }
        
        // Set up trace with default options
        const trace = {
            z: transposedData,
            type: 'heatmap',
            colorscale: colorscale,
            showscale: true
        };
        
        // Set up layout with default options
        const layout = {
            title: {
                text: title,
                font: { size: 16 }
            },
            margin: { t: 40, r: 40, b: 30, l: 40 },
            xaxis: { 
                showticklabels: false,
                // Set initial range explicitly
                range: [0, transposedData[0].length],
                constrain: 'domain'
            },
            yaxis: { 
                showticklabels: false,
                // Set initial range explicitly
                range: [0, transposedData.length],
                constrain: 'domain'
            },
            coloraxis: {
                colorbar: {
                    thickness: 20,
                    len: 0.7
                }
            },
            // Add explicit dimensions to maintain consistent plot size
            autosize: false,
            width: container.clientWidth,
            height: container.clientHeight || 400
        };
        
        // Apply custom options if provided - use layout.coloraxis.colorbar
        if (options.colorbar) {
            layout.coloraxis.colorbar = {
                ...layout.coloraxis.colorbar,
                ...options.colorbar
            };
        }
        
        const config = {
            responsive: true,
            displayModeBar: false,
            scrollZoom: true
        };
        
        // Use a try-catch for the plot creation
        try {
            Plotly.newPlot(container, [trace], layout, config).then(() => {
                // After plot is created, set up enhanced zoom limits with touchpad support
                const zoomLimits = {
                    MAX_ZOOM_IN: 5,     // 5x zoom in limit
                    MAX_ZOOM_OUT: 5,    // 5x zoom out limit
                    TOUCHPAD_SENSITIVITY_ADJUST: 0.2  // Reduce touchpad sensitivity (lower = stricter)
                };
                
                // Store original dimensions for zoom calculations
                container._origData = {
                    width: transposedData[0].length,
                    height: transposedData.length
                };
                
                // Track the last known zoom level
                container._currentZoom = 1;
                
                // Track time between wheel events to detect rapid touchpad scrolling
                container._lastWheelTime = 0;
                container._wheelEventCount = 0;
                
                // Track if we're in a touchpad rapid zoom sequence
                container._isTouchpadRapidZoom = false;
                
                // Add wheel event handler to limit zoom
                container.addEventListener('wheel', function(e) {
                    // Skip if we don't have layout or origData
                    if (!container.layout || !container.layout.xaxis || 
                        !container.layout.yaxis || !container._origData) {
                        return;
                    }
                    
                    try {
                        // Get current ranges
                        const xRange = container.layout.xaxis.range;
                        const yRange = container.layout.yaxis.range;
                        
                        // Calculate current view sizes
                        const xSize = Math.abs(xRange[1] - xRange[0]);
                        const ySize = Math.abs(yRange[1] - yRange[0]);
                        
                        // Calculate zoom ratios
                        const xZoom = container._origData.width / xSize;
                        const yZoom = container._origData.height / ySize;
                        
                        // Get the higher zoom ratio (more zoomed in)
                        const currentZoom = Math.max(xZoom, yZoom);
                        
                        // Update the stored zoom level
                        container._currentZoom = currentZoom;
                        
                        // Check if zooming in or out
                        const zoomingIn = e.deltaY < 0;
                        const zoomingOut = e.deltaY > 0;
                        
                        // Touchpad detection - check for rapid successive events
                        const now = Date.now();
                        const timeSinceLastWheel = now - (container._lastWheelTime || 0);
                        container._lastWheelTime = now;
                        
                        // Reset counter if it's been a while since last event
                        if (timeSinceLastWheel > 100) {
                            container._wheelEventCount = 0;
                            container._isTouchpadRapidZoom = false;
                        }
                        
                        // Increment wheel event counter
                        container._wheelEventCount++;
                        
                        // Detect touchpad by checking for small deltas and rapid events
                        const isTouchpadLike = (
                            Math.abs(e.deltaY) < 20 && 
                            timeSinceLastWheel < 50 && 
                            container._wheelEventCount > 3
                        );
                        
                        if (isTouchpadLike) {
                            container._isTouchpadRapidZoom = true;
                        }
                        
                        // Apply stricter limits for touchpad-like behavior
                        let effectiveMaxZoomIn = zoomLimits.MAX_ZOOM_IN;
                        let effectiveMinZoomOut = 1/zoomLimits.MAX_ZOOM_OUT;
                        
                        // If we detect touchpad behavior, we apply stricter limits
                        if (container._isTouchpadRapidZoom) {
                            // Make limits stricter for touchpad
                            effectiveMaxZoomIn *= zoomLimits.TOUCHPAD_SENSITIVITY_ADJUST;
                            effectiveMinZoomOut /= zoomLimits.TOUCHPAD_SENSITIVITY_ADJUST;
                        }
                        
                        // Check if we've hit limits
                        if ((zoomingIn && currentZoom >= effectiveMaxZoomIn) || 
                            (zoomingOut && currentZoom <= effectiveMinZoomOut)) {
                            // We've hit a limit - prevent further zooming
                            e.preventDefault();
                            e.stopPropagation();
                            return false;
                        }
                    } catch (err) {
                        // Silent error - don't block normal zooming if something fails
                        console.error("Error in zoom limit check:", err);
                    }
                }, { passive: false, capture: true });
                
                // Add relayout event handler to force limits after zoom
                container.on('plotly_relayout', function(eventData) {
                    // Skip if not a zoom/pan event
                    if (!eventData || (!eventData['xaxis.range[0]'] && !eventData['yaxis.range[0]'])) return;
                    
                    try {
                        // Get current ranges
                        const xRange = container.layout.xaxis.range;
                        const yRange = container.layout.yaxis.range;
                        
                        // Calculate current view sizes
                        const xSize = Math.abs(xRange[1] - xRange[0]);
                        const ySize = Math.abs(yRange[1] - yRange[0]);
                        
                        // Calculate zoom ratios
                        const xZoom = container._origData.width / xSize;
                        const yZoom = container._origData.height / ySize;
                        
                        // Get the higher zoom ratio (more zoomed in)
                        const currentZoom = Math.max(xZoom, yZoom);
                        
                        // Hard limits - enforce even after events get through
                        const ABSOLUTE_MAX_ZOOM = zoomLimits.MAX_ZOOM_IN * 1.1; // Allow slight overshoot
                        const ABSOLUTE_MIN_ZOOM = 1/(zoomLimits.MAX_ZOOM_OUT * 1.1);
                        
                        // Check if we're beyond absolute limits
                        let needsCorrection = false;
                        let newXRange = [...xRange];
                        let newYRange = [...yRange];
                        
                        if (currentZoom > ABSOLUTE_MAX_ZOOM) {
                            // Too zoomed in - zoom out to limit
                            const correction = currentZoom / ABSOLUTE_MAX_ZOOM;
                            const centerX = (xRange[0] + xRange[1]) / 2;
                            const centerY = (yRange[0] + yRange[1]) / 2;
                            const halfWidth = (xSize * correction) / 2;
                            const halfHeight = (ySize * correction) / 2;
                            
                            newXRange = [centerX - halfWidth, centerX + halfWidth];
                            newYRange = [centerY - halfHeight, centerY + halfHeight];
                            needsCorrection = true;
                        }
                        else if (currentZoom < ABSOLUTE_MIN_ZOOM) {
                            // Too zoomed out - zoom in to limit
                            const correction = ABSOLUTE_MIN_ZOOM / currentZoom;
                            const centerX = (xRange[0] + xRange[1]) / 2;
                            const centerY = (yRange[0] + yRange[1]) / 2;
                            const halfWidth = (xSize * correction) / 2;
                            const halfHeight = (ySize * correction) / 2;
                            
                            newXRange = [centerX - halfWidth, centerX + halfWidth];
                            newYRange = [centerY - halfHeight, centerY + halfHeight];
                            needsCorrection = true;
                        }
                        
                        // Apply correction if needed
                        if (needsCorrection) {
                            Plotly.relayout(container, {
                                'xaxis.range': newXRange,
                                'yaxis.range': newYRange
                            });
                        }
                    } catch (err) {
                        console.error("Error in relayout limit check:", err);
                    }
                });
            });
            
            // Set up zoom handlers
            setupEfficientZoomHandlers(container);
            
        } catch (plotError) {
            console.error("Error creating plot:", plotError);
            
            // Try a simpler fallback version without event handlers if the main one fails
            try {
                Plotly.newPlot(container, [trace], layout, {
                    responsive: true,
                    displayModeBar: false
                });
            } catch (fallbackError) {
                console.error("Fallback plot also failed:", fallbackError);
                container.innerHTML = `<div style="color:red;padding:20px;text-align:center;">
                    Unable to create visualization
                </div>`;
            }
        }
    } catch (error) {
        console.error("Critical error creating heatmap:", error);
        container.innerHTML = `<div style="color:red;padding:20px;text-align:center;">
            Error creating visualization:<br>${error.message}
        </div>`;
    }
}

        
        
        // Update parameters and visualizations without loading new microstructure
        function updateParametersOnly() {
    if (!currentResults) return;
    
    try {
        // Get parameter values
        const kappa1 = parseFloat(kappa1Input.value);
        const alpha = parseFloat(alphaInput.value);
        
        // Special case handling for kappa1 = 1 (homogeneous material)
        if (Math.abs(kappa1 - 1.0) < 0.001) {
            // Use the simplified approach for homogeneous materials
            const image = currentResults.image || getImageData(parseInt(msIdInput.value));
            
            // Create placeholder visualizations
            createHomogeneousVisualizations(image);
            
            // Update info panel with homogeneous material info
            updateInfoPanel({ vol_frac: calculateVolumeFraction(image), reuss: 1.0, voigt: 1.0, eig_kappa: [1.0, 1.0] }, 
                            parseInt(msIdInput.value), kappa1, alpha);
            
            return;
        }
        
        // Show loading overlay
        loadingOverlay.classList.remove('hidden');
        
        // Clear any existing fetch operations (to prevent race conditions)
        if (window.currentFetch) {
            window.currentFetchAbort.abort();
        }
        
        // Create a new abort controller
        const controller = new AbortController();
        const signal = controller.signal;
        window.currentFetchAbort = controller;
        
        // Add a timeout to abort the request if it takes too long
        const timeoutId = setTimeout(() => {
            controller.abort();
            console.log("Request timed out");
        }, 10000);
        
        // Track the current fetch operation
        window.currentFetch = fetch(API_SIMULATE, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                ms_id: parseInt(msIdInput.value),
                kappa1: kappa1,
                alpha: alpha
            }),
            signal // Pass the abort signal
        })
        .then(response => {
            clearTimeout(timeoutId);
            if (!response.ok) {
                return response.json().then(error => {
                    throw new Error(error.detail || 'Failed to update parameters');
                });
            }
            return response.json();
        })
        .then(results => {
            // Clear the reference to the current fetch once it completes successfully
            window.currentFetch = null;
            
            // Store the updated results
            currentResults = results;
            
            // Update info panel
            updateInfoPanel(results, parseInt(msIdInput.value), kappa1, alpha);
            
            // Update visualizations
            createVisualizations(results);
        })
        .catch(error => {
            // Only report errors that aren't due to aborted requests
            if (error.name !== 'AbortError') {
                console.error('Error updating parameters:', error);
                infoPanel.innerHTML = `
                    <p style="color: red; font-weight: bold;">Error: ${error.message}</p>
                    <p>Please check that the server is running and accessible at the correct address.</p>
                    <p>Server address: ${window.location.origin}${API_SIMULATE}</p>
                `;
            }
        })
        .finally(() => {
            // Hide loading overlay if this is still the most recent request
            if (!window.currentFetch) {
                loadingOverlay.classList.add('hidden');
            }
        });
    } catch (error) {
        console.error('Error in parameter update:', error);
        loadingOverlay.classList.add('hidden');
        infoPanel.innerHTML = `
            <p style="color: red; font-weight: bold;">Error: ${error.message}</p>
            <p>Please check your connection and try again.</p>
        `;
    }
}
        
        // Update info panel with results
        function updateInfoPanel(results, msId, kappa1, alpha) {
    // Special case for kappa1 = 1 (homogeneous material)
    if (Math.abs(kappa1 - 1.0) < 0.0001) { // Use a small epsilon for floating point comparison
        let infoHTML = `
            <div class="info-grid">
                <div class="info-item"><strong>Microstructure:</strong> ${typeof msId === 'number' ? `ID ${msId}` : msId}</div>
                <div class="info-item"><strong>Volume Fraction:</strong> ${results?.vol_frac ? results.vol_frac.toFixed(3) : 'N/A'}</div>
                <div class="info-item"><strong>κ₁:</strong> ${kappa1.toFixed(3)} W/m² (Homogeneous material)</div>
                <div class="info-item"><strong>α:</strong> ${alpha.toFixed(1)}°</div>
                <div class="info-item"><strong>Effective Thermal Conductivity Tensor:</strong> [1.0, 1.0]</div>
            </div>`;
        infoPanel.innerHTML = infoHTML;
        return;
    }
    
    // Regular case - format the effective thermal conductivity tensor instead of eigenvalues
    let effectiveTensor = results.eig_kappa || [0, 0];
    
    // Check if eigenvalues comply with Voigt and Reuss bounds
    let complianceNote = "";
    if (results.reuss && results.voigt && 
        effectiveTensor[0] >= results.reuss && 
        effectiveTensor[0] <= results.voigt && 
        effectiveTensor[1] >= results.reuss && 
        effectiveTensor[1] <= results.voigt) {
        complianceNote = " <span style='color:green;'>(Complying with Voigt and Reuss bounds)</span>";
    }
    
    let infoHTML = `
        <div class="info-grid">
            <div class="info-item"><strong>Microstructure:</strong> ${typeof msId === 'number' ? `ID ${msId}` : msId}</div>
            <div class="info-item"><strong>Volume Fraction:</strong> ${results.vol_frac.toFixed(3)}</div>
            <div class="info-item"><strong>κ₁:</strong> ${kappa1.toFixed(3)} W/m²</div>
            <div class="info-item"><strong>α:</strong> ${alpha.toFixed(1)}°</div>
            <div class="info-item"><strong>Reuss Bound:</strong> ${results.reuss.toFixed(4)}</div>
            <div class="info-item"><strong>Voigt Bound:</strong> ${results.voigt.toFixed(4)}</div>
            <div class="info-item"><strong>Effective Thermal Conductivity Tensor:</strong> [${effectiveTensor[0].toFixed(4)}, ${effectiveTensor[1].toFixed(4)}]${complianceNote}</div>
    `;
    
    // Add surrogate results if available
    if (results.surrogate_results) {
        infoHTML += `
            <div class="info-item"><strong>Predicted Effective Tensor:</strong> [${results.surrogate_results.eig_pred[0].toFixed(4)}, ${results.surrogate_results.eig_pred[1].toFixed(4)}]</div>
        `;
    }
    
    infoHTML += `</div>`;
    infoPanel.innerHTML = infoHTML;
}
        
        // Create visualizations with the results
        function createVisualizations(results) {
            // Fixed temperature scales from -0.08 to 0.08 with 0.02 increments
            const tempTicks = [-0.08, -0.06, -0.04, -0.02, 0, 0.02, 0.04, 0.06, 0.08];
            
            // Fixed flux scales from 0.4 to 1.4 with 0.2 increments
            const fluxTicks = [0.4, 0.6, 0.8, 1.0, 1.2, 1.4];
            
            // Set options for temperature plots
            const tempOptions = {
                colorbar: {
                    tickvals: tempTicks,
                    ticktext: tempTicks.map(val => val.toFixed(2)),
                    tickmode: 'array'
                }
            };
            
            // Set options for flux plots
            const fluxOptions = {
                colorbar: {
                    tickvals: fluxTicks,
                    ticktext: fluxTicks.map(val => val.toFixed(1)),
                    tickmode: 'array'
                }
            };
            
            // Create visualizations
            createHeatmap(microPlot, results.image, 'Microstructure', 'Viridis');
            createHeatmap(paramFieldPlot, results.param_field, 'Thermal Conductivity Field', 'Viridis');
            createHeatmap(temp0Plot, results.temp0, 'Temperature Fluctuation (Load Case 1)', 'Jet', tempOptions);
            createHeatmap(temp1Plot, results.temp1, 'Temperature Fluctuation (Load Case 2)', 'Jet', tempOptions);
            createHeatmap(flux0Plot, results.flux_norm0, 'Heat Flux Magnitude (Load Case 1)', 'Jet', fluxOptions);
            createHeatmap(flux1Plot, results.flux_norm1, 'Heat Flux Magnitude (Load Case 2)', 'Jet', fluxOptions);
        }
        
        // Run simulation and update visualizations
        async function runSimulation() {
    // Show loading overlay
    loadingOverlay.classList.remove('hidden');
    
    try {
        // Get parameter values
        const msId = parseInt(msIdInput.value);
        const kappa1 = parseFloat(kappa1Input.value);
        const alpha = parseFloat(alphaInput.value);
        
        // Validate microstructure ID
        if (msId < 0 || msId > maxSampleId) {
            throw new Error(`Microstructure ID must be between 0 and ${maxSampleId}`);
        }
        
        // Special case handling for kappa1 = 1 (homogeneous material)
        if (Math.abs(kappa1 - 1.0) < 0.001) {
            // Create a simplified response for homogeneous material
            const image = await getImageData(msId);
            
            // Calculate volume fraction for the info panel
            const volFrac = calculateVolumeFraction(image);
            
            // Create placeholder visualizations for homogeneous material
            createHomogeneousVisualizations(image);
            
            // Update info panel with homogeneous material info
            updateInfoPanel({ vol_frac: volFrac, reuss: 1.0, voigt: 1.0, eig_kappa: [1.0, 1.0] }, msId, kappa1, alpha);
            
            // Hide loading overlay
            loadingOverlay.classList.add('hidden');
            return;
        }
        
        // Create a timeout handler
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);
        
        // Call API with timeout
        try {
            const response = await fetch(API_SIMULATE, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ms_id: msId,
                    kappa1: kappa1,
                    alpha: alpha
                }),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Failed to run simulation');
            }
            
            const results = await response.json();
            
            // Store the results
            currentResults = results;
            
            // Update info panel
            updateInfoPanel(results, msId, kappa1, alpha);
            
            // Create visualizations
            createVisualizations(results);
            
        } catch (error) {
            if (error.name === 'AbortError') {
                throw new Error('Request timed out. The server may be busy or unavailable.');
            } else {
                throw error;
            }
        }
        
    } catch (error) {
        console.error('Error running simulation:', error);
        infoPanel.innerHTML = `
            <p style="color: red; font-weight: bold;">Error: ${error.message}</p>
            <p>Server address: ${window.location.origin}${API_SIMULATE}</p>
            <p>If this error persists, check that the server is running and accessible.</p>
        `;
    } finally {
        // Hide loading overlay
        loadingOverlay.classList.add('hidden');
    }
} 

async function getImageData(msId) {
    // Try to get from current results if available
    if (currentResults && currentResults.image) {
        return currentResults.image;
    }
    
    // Otherwise, use a default uniform grid
    const gridSize = 400;
    const image = [];
    for (let i = 0; i < gridSize; i++) {
        const row = [];
        for (let j = 0; j < gridSize; j++) {
            // Create a simple checkerboard pattern
            row.push((i + j) % 16 < 8 ? 1 : 0);
        }
        image.push(row);
    }
    return image;
}

function calculateVolumeFraction(image) {
    if (!image || !image.length) return 0.5;
    
    let sum = 0;
    let count = 0;
    
    for (let i = 0; i < image.length; i++) {
        for (let j = 0; j < image[i].length; j++) {
            sum += image[i][j];
            count++;
        }
    }
    
    return count > 0 ? sum / count : 0.5;
}

function createHomogeneousVisualizations(image) {
    // Store image in currentResults
    if (!currentResults) {
        currentResults = {};
    }
    currentResults.image = image;
    
    // Create a uniform field for parameters (all 1's)
    const paramField = [];
    for (let i = 0; i < image.length; i++) {
        const row = [];
        for (let j = 0; j < image[0].length; j++) {
            row.push(1.0);
        }
        paramField.push(row);
    }
    
    // Create uniform fields for temperatures (all zeros for fluctuations)
    const tempField = [];
    for (let i = 0; i < image.length; i++) {
        const row = [];
        for (let j = 0; j < image[0].length; j++) {
            row.push(0.0);
        }
        tempField.push(row);
    }
    
    // Create uniform fields for flux (all 1's for constant heat flow)
    const fluxField = [];
    for (let i = 0; i < image.length; i++) {
        const row = [];
        for (let j = 0; j < image[0].length; j++) {
            row.push(1.0);
        }
        fluxField.push(row);
    }
    
    // Create visualizations with special labels for homogeneous case
    createHeatmap(microPlot, image, 'Microstructure', 'Viridis');
    createHeatmap(paramFieldPlot, paramField, 'Thermal Conductivity Field (Homogeneous κ=1)', 'Viridis');
    createHeatmap(temp0Plot, tempField, 'Temperature Fluctuation (Load Case 1, Homogeneous)', 'Jet');
    createHeatmap(temp1Plot, tempField, 'Temperature Fluctuation (Load Case 2, Homogeneous)', 'Jet');
    createHeatmap(flux0Plot, fluxField, 'Heat Flux Magnitude (Load Case 1, Homogeneous)', 'Jet');
    createHeatmap(flux1Plot, fluxField, 'Heat Flux Magnitude (Load Case 2, Homogeneous)', 'Jet');
    
    // Update currentResults with generated fields
    currentResults.param_field = paramField;
    currentResults.temp0 = tempField;
    currentResults.temp1 = tempField;
    currentResults.flux_norm0 = fluxField;
    currentResults.flux_norm1 = fluxField;
    currentResults.vol_frac = calculateVolumeFraction(image);
    currentResults.reuss = 1.0;
    currentResults.voigt = 1.0;
    currentResults.eig_kappa = [1.0, 1.0];
}
        
        // Process drawn microstructure
        async function processDrawing() {
    if (!canvas) return;
    
    // Show loading overlay
    loadingOverlay.classList.remove('hidden');
    
    try {
        // Create a temporary canvas to perform the rotation
        const tempCanvas = document.createElement('canvas');
        // Swap width and height for 90-degree rotation
        tempCanvas.width = canvas.height;
        tempCanvas.height = canvas.width;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Apply 90-degree clockwise rotation
        tempCtx.translate(tempCanvas.width, 0);
        tempCtx.rotate(Math.PI/2);
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get the rotated canvas data as base64
        const drawingData = tempCanvas.toDataURL('image/png');
        
        // Get parameters
        const kappa1 = parseFloat(kappa1Input.value);
        const alpha = parseFloat(alphaInput.value);
        
        // Special case handling for kappa1 = 1 (homogeneous material)
        if (Math.abs(kappa1 - 1.0) < 0.001) {
            // Convert the ROTATED drawing to binary image data for consistency
            const drawingBinary = await convertCanvasToArray(tempCanvas);
            
            // Create homogeneous visualizations
            createHomogeneousVisualizations(drawingBinary);
            
            // Update info panel
            updateInfoPanel({ 
                vol_frac: calculateVolumeFraction(drawingBinary), 
                reuss: 1.0, 
                voigt: 1.0, 
                eig_kappa: [1.0, 1.0] 
            }, 'Custom Drawing', kappa1, alpha);
            
            // Hide loading overlay
            loadingOverlay.classList.add('hidden');
            return;
        }
        
        // Create form data
        const formData = new FormData();
        formData.append('drawing', drawingData);
        formData.append('kappa1', kappa1);
        formData.append('alpha', alpha);
        
        // Send to API
        const response = await fetch(API_DRAWING, {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to process drawing');
        }
        
        const results = await response.json();
        
        // Store the results
        currentResults = results;
        
        // Update info panel
        updateInfoPanel(results, 'Custom Drawing', kappa1, alpha);
        
        // Create visualizations
        createVisualizations(results);
        
    } catch (error) {
        console.error('Error processing drawing:', error);
        infoPanel.innerHTML = `<p style="color: red; font-weight: bold;">Error: ${error.message}</p>`;
    } finally {
        // Hide loading overlay
        loadingOverlay.classList.add('hidden');
    }
}

async function convertCanvasToArray(canvas) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const result = [];
    
    // Create binary array from image data
    for (let y = 0; y < canvas.height; y++) {
        const row = [];
        for (let x = 0; x < canvas.width; x++) {
            const idx = (y * canvas.width + x) * 4;
            // Check if pixel is white (RGB values all above 128)
            const isWhite = data[idx] > 128 && data[idx + 1] > 128 && data[idx + 2] > 128;
            row.push(isWhite ? 1 : 0);
        }
        result.push(row);
    }
    
    return result;
}
        
        function resetPlot(plotId) {
            console.log('Resetting plot:', plotId);
            const plotElement = document.getElementById(plotId);
            if (plotElement && plotElement.layout) {
                Plotly.relayout(plotElement, {
                    'xaxis.autorange': true,
                    'yaxis.autorange': true
                });
                
                // Reset colorbar ticks to original range
                if (plotId.includes('temp')) {
                    // Fixed temperature scales from -0.08 to 0.08 with 0.02 increments
                    const tempTicks = [-0.08, -0.06, -0.04, -0.02, 0, 0.02, 0.04, 0.06, 0.08];
                    Plotly.relayout(plotElement, {
                        'coloraxis.colorbar.tickvals': tempTicks,
                        'coloraxis.colorbar.ticktext': tempTicks.map(val => val.toFixed(2))
                    });
                } else if (plotId.includes('flux')) {
                    // Fixed flux scales from 0.4 to 1.4 with 0.2 increments
                    const fluxTicks = [0.4, 0.6, 0.8, 1.0, 1.2, 1.4];
                    Plotly.relayout(plotElement, {
                        'coloraxis.colorbar.tickvals': fluxTicks,
                        'coloraxis.colorbar.ticktext': fluxTicks.map(val => val.toFixed(1))
                    });
                }
            }
        }
        
        function downloadPlot(plotId) {
            console.log('Downloading plot:', plotId);
            const plotElement = document.getElementById(plotId);
            if (plotElement) {
                Plotly.downloadImage(plotElement, {
                    format: 'png',
                    filename: plotId,
                    height: 800,
                    width: 800
                });
            }
        }
        
        // Toggle between different display modes (e.g., heatmap vs. contour) - IMPROVED VERSION
        let plotModes = {};  // Store current mode for each plot
        
        function toggleDisplayMode(plotId) {
            console.log('Toggling display mode for plot:', plotId);
            const plotElement = document.getElementById(plotId);
            if (!plotElement || !plotElement.data || !plotElement.data[0]) {
                console.error('Plot element or data not found:', plotId);
                return;
            }
            
            try {
                // Get current mode or default to 'heatmap'
                plotModes[plotId] = plotModes[plotId] || 'heatmap';
                
                // Get current data
                const currentData = plotElement.data[0].z;
                const currentTitle = plotElement.layout.title.text;
                const colorscale = plotElement.data[0].colorscale || 'Jet';
                
                // Get layout settings to preserve
                const currentLayout = plotElement.layout;
                
                // Capture dimensions to preserve
                const width = currentLayout.width || plotElement.clientWidth;
                const height = currentLayout.height || plotElement.clientHeight;
                
                // Preserve the last zoom state if it exists
                const lastZoomState = plotElement._lastZoomState;
                
                // Purge the plot before recreating to avoid memory issues
                Plotly.purge(plotElement);
                
                if (plotModes[plotId] === 'heatmap') {
                    // Switch to contour
                    console.log('Switching to contour mode');
                    plotModes[plotId] = 'contour';
                    
                    const newTrace = {
                        z: currentData,
                        type: 'contour',
                        colorscale: colorscale,
                        showscale: true,
                        contours: {
                            coloring: 'heatmap'
                        }
                    };
                    
                    // Preserve coloraxis settings and dimensions
                    const newLayout = {
                        ...currentLayout,
                        title: { text: currentTitle, font: { size: 16 } },
                        width: width,
                        height: height,
                        autosize: false
                    };
                    
                    // Create new plot with error handling - use the same efficient zoom handler
                    try {
                        Plotly.newPlot(plotElement, [newTrace], newLayout, {
                            responsive: true,
                            displayModeBar: false,
                            scrollZoom: true
                        });
                        
                        // Restore last zoom state
                        plotElement._lastZoomState = lastZoomState;
                        
                        // Set up the same efficient zoom handlers as in createHeatmap
                        setupEfficientZoomHandlers(plotElement);
                    } catch (e) {
                        console.error("Error creating contour plot:", e);
                        // Revert the mode if failed
                        plotModes[plotId] = 'heatmap';
                    }
                } else {
                    // Switch back to heatmap
                    console.log('Switching to heatmap mode');
                    plotModes[plotId] = 'heatmap';
                    
                    const newTrace = {
                        z: currentData,
                        type: 'heatmap',
                        colorscale: colorscale,
                        showscale: true
                    };
                    
                    // Preserve coloraxis settings and dimensions
                    const newLayout = {
                        ...currentLayout,
                        title: { text: currentTitle, font: { size: 16 } },
                        width: width,
                        height: height,
                        autosize: false
                    };
                    
                    // Create new plot with error handling - use the same efficient zoom handler
                    try {
                        Plotly.newPlot(plotElement, [newTrace], newLayout, {
                            responsive: true,
                            displayModeBar: false,
                            scrollZoom: true
                        });
                        
                        // Restore last zoom state
                        plotElement._lastZoomState = lastZoomState;
                        
                        // Set up the same efficient zoom handlers as in createHeatmap
                        setupEfficientZoomHandlers(plotElement);
                    } catch (e) {
                        console.error("Error creating heatmap plot:", e);
                        // Revert the mode if failed
                        plotModes[plotId] = 'contour';
                    }
                }
            } catch (error) {
                console.error("Error toggling plot mode:", error);
            }
        }
        
        // Handle image upload
        let uploadedImage = null;
        
        // Enable the Process button when an image is selected
        imageUpload.addEventListener('change', function(e) {
            if (this.files && this.files[0]) {
                processUploadBtn.disabled = false;
            } else {
                processUploadBtn.disabled = true;
            }
        });
        
        // Process the uploaded image
        processUploadBtn.addEventListener('click', function() {
            if (imageUpload.files && imageUpload.files[0]) {
                // Show loading overlay
                loadingOverlay.classList.remove('hidden');
                
                const file = imageUpload.files[0];
                const formData = new FormData();
                formData.append('file', file);
                formData.append('kappa1', parseFloat(kappa1Input.value));
                formData.append('alpha', parseFloat(alphaInput.value));
                
                // Upload the image and process it
                fetch(API_UPLOAD, {
                    method: 'POST',
                    body: formData
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(error => {
                            throw new Error(error.detail || 'Failed to process image');
                        });
                    }
                    return response.json();
                })
                .then(results => {
                    // Store the results
                    currentResults = results;
                    
                    // Update info panel with custom message
                    updateInfoPanel(results, 'Uploaded Image', parseFloat(kappa1Input.value), parseFloat(alphaInput.value));
                    
                    // Create visualizations
                    createVisualizations(results);
                })
                .catch(error => {
                    console.error('Error processing uploaded image:', error);
                    infoPanel.innerHTML = `<p style="color: red; font-weight: bold;">Error: ${error.message}</p>`;
                })
                .finally(() => {
                    // Hide loading overlay
                    loadingOverlay.classList.add('hidden');
                });
            }
        });
        
        // Process the drawn microstructure
        processDrawingBtn.addEventListener('click', function() {
            processDrawing();
        });
        
        // Debounced version of parameter update
        const debouncedUpdateParameters = debounce(updateParametersOnly, 300);
        
        // Update displayed values for sliders and update visualization
        kappa1Input.addEventListener('input', () => {
            // Just update the displayed value immediately
            kappa1Value.textContent = parseFloat(kappa1Input.value).toFixed(2);
        });
        
        // Update on slider release rather than continuous input
        kappa1Input.addEventListener('change', () => {
            // Update visualization when slider is released if we have current results
            if (currentResults) {
                debouncedUpdateParameters();
            }
        });
        
        alphaInput.addEventListener('input', () => {
            // Just update the displayed value immediately
            alphaValue.textContent = alphaInput.value + '°';
        });
        
        // Update on slider release rather than continuous input
        alphaInput.addEventListener('change', () => {
            // Update visualization when slider is released if we have current results
            if (currentResults) {
                debouncedUpdateParameters();
            }
        });
        
        // Add event listeners for all plot buttons
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listeners to all buttons
            document.querySelectorAll('.plot-button').forEach(button => {
                button.addEventListener('click', function(e) {
                    const plotId = this.getAttribute('data-plot-id');
                    const action = this.getAttribute('data-action');
                    
                    if (action === 'reset') {
                        resetPlot(plotId);
                    } else if (action === 'download') {
                        downloadPlot(plotId);
                    } else if (action === 'toggle') {
                        toggleDisplayMode(plotId);
                    }
                });
            });

            // Ensure all shape tools reset to normal drawing mode after use
document.querySelectorAll('.shape-tool').forEach(button => {
    if (button.id !== 'draw-line') { // Skip line tool which has special handling
        button.addEventListener('click', function() {
            // If we're in a special drawing mode, clean it up first
            if (currentDrawingMode) {
                currentDrawingMode();
                currentDrawingMode = null;
            }
            
            // Reset back to the active drawing tool after shape is drawn
            setTimeout(() => {
                if (drawColor === '#FFFFFF') {
                    setActiveDrawingTool(drawWhiteBtn);
                } else {
                    setActiveDrawingTool(drawBlackBtn);
                }
            }, 100);
        });
    }
});

    // Add the upload size restriction notice
    const uploadInfo = document.querySelector('.upload-info');
    if (uploadInfo) {
        uploadInfo.innerHTML = `
            <small>Supported formats: PNG, JPEG, GIF. Images will be processed as binary (black/white) microstructures, where white represents the conductive phase. <strong>Images will be restricted to 400x400px - larger images will be cropped to the top-left corner.</strong></small>
        `;
    }
    
    // Add warning for kappa1 near 1
    kappa1Input.addEventListener('input', () => {
    const kappa1 = parseFloat(kappa1Input.value);
    const kappa1ValueElem = document.getElementById('kappa1-value');
    
    // Just update the displayed value immediately
    kappa1ValueElem.textContent = kappa1.toFixed(2);
    
    // Add warning if kappa1 is exactly 1 or very close to 1
    if (Math.abs(kappa1 - 1.0) < 0.001) {
        kappa1ValueElem.innerHTML = `${kappa1.toFixed(2)} <span style="color:#e74c3c">(homogeneous material)</span>`;
    } else if (Math.abs(kappa1 - 1.0) < 0.05) {
        kappa1ValueElem.innerHTML = `${kappa1.toFixed(2)} <span style="color:orange">(near homogeneous)</span>`;
    }
});
            
            // Add event listener for the Load Microstructure button
            updateBtn.addEventListener('click', runSimulation);
            
            // Initialize the application
            initApp();
            
            // Initialize drawing tools
            if (canvas) {
                initializeDrawingTools();
            }
            
            // Initialize collapsible sections - all start expanded
            document.querySelectorAll('.toolbar-content').forEach(content => {
            content.classList.add('collapsed');
            content.style.maxHeight = '0px';
            });
        });
    </script>
    </body>
    </html>